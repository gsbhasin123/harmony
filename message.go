package discord

import (
	"encoding/json"
	"io"
	"net/http"
	"time"

	"github.com/skwair/discord/embed"
	"github.com/skwair/discord/internal/endpoint"
)

// MessageType describes the type of a message. Different fields
// are set or not depending on the message's type.
type MessageType int

// supported message types :
const (
	Default MessageType = iota
	RecipientAdd
	RecipientRemove
	Call
	ChannelNameChange
	ChannelIconChange
	ChannelPinnedMessage
	GuildMemberJoin
)

// Message represents a message sent in a channel within Discord.
// The author object follows the structure of the user object, but is
// only a valid user in the case where the message is generated by a
// user or bot user. If the message is generated by a webhook, the
// author object corresponds to the webhook's id, username, and avatar.
// You can tell if a message is generated by a webhook by checking for
// the webhook_id on the message object.
type Message struct {
	ID              string        `json:"id"`
	ChannelID       string        `json:"channel_id"`
	GuildID         string        `json:"guild_id"`
	Author          *User         `json:"author"`
	Content         string        `json:"content"`
	Timestamp       time.Time     `json:"timestamp"`
	EditedTimestamp time.Time     `json:"edited_timestamp"`
	TTS             bool          `json:"tts"`
	MentionEveryone bool          `json:"mention_everyone"`
	Mentions        []User        `json:"mentions"`
	MentionRoles    []string      `json:"mention_roles"` // Role IDs
	Attachments     []Attachment  `json:"attachments"`   // Any attached files.
	Embeds          []embed.Embed `json:"embeds"`        // Any embedded content.
	Reactions       []Reaction    `json:"reactions"`
	Nonce           string        `json:"nonce"` // Used for validating a message was sent.
	Pinned          bool          `json:"pinned"`
	WebhookID       string        `json:"webhook_id"`
	Type            MessageType   `json:"type"`

	// Sent with Rich Presence-related chat embeds.
	Activity    *MessageActivity    `json:"activity"`
	Application *MessageApplication `json:"application"`
}

// Attachment is file attached to a message.
type Attachment struct {
	ID       string `json:"id"`
	Filename string `json:"filename"`
	Size     int    `json:"size"`
	URL      string `json:"url"`
	ProxyURL string `json:"proxy_url"`
	Height   int    `json:"height"`
	Width    int    `json:"width"`
}

// createMessage describes a message creation.
type createMessage struct {
	Content string       `json:"content,omitempty"` // Up to 2000 characters.
	Nonce   string       `json:"nonce,omitempty"`
	TTS     bool         `json:"tts,omitempty"`
	Embed   *embed.Embed `json:"embed,omitempty"`
}

// json implements the multipartPayload interface so createMessage can be used as
// a payload with the multipartFromFiles method.
func (cm *createMessage) json() ([]byte, error) {
	return json.Marshal(cm)
}

func (c *Client) sendMessage(channelID string, msg *createMessage) (*Message, error) {
	if msg.Embed != nil && msg.Embed.Type == "" {
		msg.Embed.Type = "rich"
	}

	b, err := json.Marshal(msg)
	if err != nil {
		return nil, err
	}

	e := endpoint.CreateMessage(channelID)
	resp, err := c.doReq(http.MethodPost, e, b)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, apiError(resp)
	}

	var m Message
	if err = json.NewDecoder(resp.Body).Decode(&m); err != nil {
		return nil, err
	}
	return &m, nil
}

// SendSimpleMessage is like SendMessage with an empty nonce and text to speech set to false.
func (c *Client) SendSimpleMessage(channelID, text string) (*Message, error) {
	return c.SendMessage(channelID, text, "", false)
}

// SendMessage posts a message to a guild text or DM channel. If operating on a guild
// channel, this endpoint requires the 'SEND_MESSAGES' permission to be present on the
// current user. If the tts field is set to true, the 'SEND_TTS_MESSAGES' permission is
// required for the message to be spoken. Returns a message object.
// Fires a Message Create Gateway event.
// Before using this endpoint, you must connect to the gateway at least once.
// The nonce will be returned in the result and also transmitted to other clients.
// You can set it to empty if you do not need this feature.
func (c *Client) SendMessage(channelID, text, nonce string, tts bool) (*Message, error) {
	return c.sendMessage(channelID, &createMessage{
		Content: text,
		Nonce:   nonce,
		TTS:     tts,
	})
}

// SendSimpleEmbed is like SendEmbed with an empty nonce and text to speech set to false.
func (c *Client) SendSimpleEmbed(channelID, text string, embed *embed.Embed) (*Message, error) {
	return c.SendEmbed(channelID, text, "", false, embed)
}

// SendEmbed sends some embedded rich content attached to a message on a given channel.
// See SendMessage for required permissions and the embed sub package for more information
// about embeds.
func (c *Client) SendEmbed(channelID, text, nonce string, tts bool, embed *embed.Embed) (*Message, error) {
	return c.sendMessage(channelID, &createMessage{
		Content: text,
		Nonce:   nonce,
		TTS:     tts,
		Embed:   embed,
	})
}

// File is a file along with its name. It is used to send files
// to channels with SendFiles.
type File struct {
	Name   string
	Reader io.Reader
}

// SendFiles sends some attached files with an optional text and/or embedded rich
// content on a given channel.
// See SendMessage for required permissions and the embed sub package for more information
// about embeds.
func (c *Client) SendFiles(channelID, text, nonce string, embed *embed.Embed, files ...File) (*Message, error) {
	if len(files) < 1 {
		return nil, ErrNoFileProvided
	}

	cm := &createMessage{
		Content: text,
		Embed:   embed,
		Nonce:   nonce,
		TTS:     false,
	}
	b, h, err := multipartFromFiles(cm, files...)
	if err != nil {
		return nil, err
	}

	e := endpoint.CreateMessage(channelID)
	resp, err := c.doReqWithHeader(http.MethodPost, e, b, h)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, apiError(resp)
	}

	var m Message
	if err = json.NewDecoder(resp.Body).Decode(&m); err != nil {
		return nil, err
	}
	return &m, nil
}

type editMessage struct {
	Content string       `json:"content,omitempty"`
	Embed   *embed.Embed `json:"embed,omitempty"`
}

func (c *Client) editMessage(channelID, messageID string, edit *editMessage) (*Message, error) {
	b, err := json.Marshal(edit)
	if err != nil {
		return nil, err
	}

	e := endpoint.EditMessage(channelID, messageID)
	resp, err := c.doReq(http.MethodPatch, e, b)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, apiError(resp)
	}

	var msg Message
	if err = json.NewDecoder(resp.Body).Decode(&msg); err != nil {
		return nil, err
	}
	return &msg, nil
}

// EditMessage edits a previously sent message. You can only edit messages that have
// been sent by the current user. Fires a Message Update Gateway event. See EditEmbed
// if you need to edit some emeded content.
func (c *Client) EditMessage(channelID, messageID, content string) (*Message, error) {
	return c.editMessage(channelID, messageID, &editMessage{content, nil})
}

// EditEmbed is like EditMessage but with embeded content support.
func (c *Client) EditEmbed(channelID, messageID, content string, embed *embed.Embed) (*Message, error) {
	return c.editMessage(channelID, messageID, &editMessage{content, embed})
}

// DeleteMessage deletes a message. If operating on a guild channel and trying to delete a
// message that was not sent by the current user, this endpoint requires the 'MANAGE_MESSAGES'
// permission. Fires a Message Delete Gateway event.
func (c *Client) DeleteMessage(channelID, messageID string) error {
	e := endpoint.DeleteMessage(channelID, messageID)
	resp, err := c.doReq(http.MethodDelete, e, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent {
		return apiError(resp)
	}
	return nil
}

// DeleteMessageBulk seletes multiple messages in a single request. This endpoint can only be
// used on guild channels and requires the 'MANAGE_MESSAGES' permission. Fires multiple
// Message Delete Gateway events.
// Any message IDs given that do not exist or are invalid will count towards the minimum and
// maximum message count (currently 2 and 100 respectively). Additionally, duplicated IDs will
// only be counted once.
func (c *Client) DeleteMessageBulk(channelID string, messageIDs []string) error {
	s := struct {
		Messages []string `json:"messages"`
	}{
		Messages: messageIDs,
	}
	b, err := json.Marshal(s)
	if err != nil {
		return err
	}

	e := endpoint.BulkDeleteMessage(channelID)
	resp, err := c.doReq(http.MethodPost, e, b)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent {
		return apiError(resp)
	}
	return nil
}

// GetPins returns all pinned messages in a channel as an array of messages.
func (c *Client) GetPins(channelID string) ([]Message, error) {
	e := endpoint.GetPins(channelID)
	resp, err := c.doReq(http.MethodGet, e, nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, apiError(resp)
	}

	var messages []Message
	if err = json.NewDecoder(resp.Body).Decode(&messages); err != nil {
		return nil, err
	}
	return messages, nil
}

// PinMessage pins a message in a channel. Requires the 'MANAGE_MESSAGES' permission.
func (c *Client) PinMessage(channelID, messageID string) error {
	e := endpoint.PinMessage(channelID, messageID)
	resp, err := c.doReq(http.MethodPut, e, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent {
		return apiError(resp)
	}
	return nil
}

// UnpinMessage deletes a pinned message in a channel. Requires the
// 'MANAGE_MESSAGES' permission.
func (c *Client) UnpinMessage(channelID, messageID string) error {
	e := endpoint.UnpinMessage(channelID, messageID)
	resp, err := c.doReq(http.MethodDelete, e, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent {
		return apiError(resp)
	}
	return nil
}
